/**
 * source/funkin/ui/editors/components/UI/properties/Properties.js
 * Controlador que sincroniza la ventana de Propiedades HTML con el elemento seleccionado en Phaser.
 */
export default class Properties {
    /**
     * @param {Phaser.Scene} scene - La escena del editor (StageEditor).
     */
    constructor(scene) {
        this.scene = scene;
        this.targetElement = null;
        this.isUpdatingUI = false; // Evita bucles infinitos (Input -> Objeto -> Input)

        // Referencias a los elementos del DOM (HTML)
        // Buscamos por ID, asegúrate de que el HTML tenga estos IDs
        this.dom = {
            container: document.getElementById('propList'),
            emptyState: document.getElementById('propEmpty'),
            
            // Inputs
            visible: document.getElementById('prop-visible'),
            colorPreview: document.getElementById('prop-color-preview'),
            colorText: document.getElementById('prop-color-text'),
            alpha: document.getElementById('prop-alpha'),
            x: document.getElementById('prop-x'),
            y: document.getElementById('prop-y')
        };

        this._initListeners();
        this._bindInputEvents();
    }

    /**
     * Escucha los eventos que emite Elements.js
     */
    _initListeners() {
        // Evento: Alguien seleccionó un objeto (o deseleccionó si es null)
        this.scene.events.on('element_selected', (element) => {
            this.setTarget(element);
        });

        // Evento: El objeto se movió (arrastrando o flechas)
        this.scene.events.on('element_updated', (element) => {
            if (this.targetElement === element) {
                this.updateUIFromElement();
            }
        });
    }

    /**
     * Define qué objeto estamos editando actualmente
     */
    setTarget(element) {
        this.targetElement = element;

        if (!element) {
            this._showEmptyState(true);
            return;
        }

        this._showEmptyState(false);
        this.updateUIFromElement();
    }

    /**
     * Copia los valores del Objeto Phaser -> Inputs HTML
     */
    updateUIFromElement() {
        if (!this.targetElement || !this.targetElement.active) return;

        this.isUpdatingUI = true;

        // 1. Transformación
        // Redondeamos para evitar decimales infinitos en la UI
        if (this.dom.x) this.dom.x.value = Math.round(this.targetElement.x * 10) / 10;
        if (this.dom.y) this.dom.y.value = Math.round(this.targetElement.y * 10) / 10;
        
        // 2. Apariencia
        if (this.dom.visible) this.dom.visible.checked = this.targetElement.visible;
        if (this.dom.alpha) this.dom.alpha.value = this.targetElement.alpha.toFixed(2);

        // 3. Color
        this._updateColorUI();

        this.isUpdatingUI = false;
    }

    /**
     * Maneja la lógica de color (detecta si es Tint o Fill)
     */
    _updateColorUI() {
        let colorInt = 0xFFFFFF;

        // Sprites/Imágenes usan tintTopLeft, Rectángulos usan fillColor
        if (this.targetElement.tintTopLeft !== undefined) {
            colorInt = this.targetElement.tintTopLeft;
        } else if (this.targetElement.fillColor !== undefined) {
            colorInt = this.targetElement.fillColor;
        }

        // Convertir entero a Hex String (#RRGGBB)
        const hexString = '#' + ('000000' + colorInt.toString(16)).slice(-6).toUpperCase();
        
        if (this.dom.colorText) this.dom.colorText.textContent = hexString;
        if (this.dom.colorPreview) this.dom.colorPreview.style.backgroundColor = hexString;
    }

    /**
     * Conecta los Inputs HTML -> Objeto Phaser
     */
    _bindInputEvents() {
        // Helper para aplicar cambios
        const updateTarget = (callback) => {
            if (this.targetElement && !this.isUpdatingUI) {
                callback(this.targetElement);
                // Opcional: Emitir 'element_updated' si otros sistemas necesitan saberlo
            }
        };

        // VISIBLE
        if (this.dom.visible) {
            this.dom.visible.addEventListener('change', (e) => {
                updateTarget((el) => el.setVisible(e.target.checked));
            });
        }

        // ALPHA
        if (this.dom.alpha) {
            this.dom.alpha.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                updateTarget((el) => el.setAlpha(Phaser.Math.Clamp(val || 1, 0, 1)));
            });
        }

        // X
        if (this.dom.x) {
            this.dom.x.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                updateTarget((el) => el.x = (isNaN(val) ? el.x : val));
            });
        }

        // Y
        if (this.dom.y) {
            this.dom.y.addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                updateTarget((el) => el.y = (isNaN(val) ? el.y : val));
            });
        }
    }

    _showEmptyState(isEmpty) {
        if (!this.dom.emptyState || !this.dom.container) return;
        
        if (isEmpty) {
            this.dom.emptyState.style.display = 'flex';
            this.dom.container.classList.remove('active');
        } else {
            this.dom.emptyState.style.display = 'none';
            this.dom.container.classList.add('active');
        }
    }

    destroy() {
        this.scene.events.off('element_selected');
        this.scene.events.off('element_updated');
    }
}